program =       "import numpy as np\n\nclass BPPSolver:\n    def __init__(self, capacity: int, weights: list[int | float]):\n        \"\"\"\n        Initialize the BPP solver.\n\n        Args:\n            capacity (int): The capacity of each bin.\n            weights (list[int | float]): A list of item weights.\n        \"\"\"\n        self.capacity = float(capacity)\n        self.weights = [float(w) for w in weights]\n        self.num_items = len(weights)\n\n    def solve(self) -> list[list[int]]:\n        \"\"\"\n        Solve the Bin Packing Problem.\n\n        Returns:\n            A list of lists, where each inner list represents a bin and contains the\n            original indices of the items packed into it.\n        \"\"\"\n        # Initial packing: Best-Fit Decreasing\n        bins, bin_loads = self._best_fit_decreasing()\n\n        # Local improvement: try to reduce number of bins by relocation and swaps\n        improved = True\n        max_iters = 200\n        it = 0\n        while improved and it < max_iters:\n            it += 1\n            improved = False\n\n            # Try to eliminate bins by relocating all their items greedily\n            # iterate bins sorted by increasing load (likely easier to eliminate)\n            order = sorted(range(len(bins)), key=lambda i: bin_loads[i])\n            for bidx in order:\n                if bidx >= len(bins):\n                    continue\n                if len(bins) == 0:\n                    break\n                if self._try_eliminate_bin(bidx, bins, bin_loads):\n                    improved = True\n                    # We modified bins/bin_loads, restart improvement loop\n                    break\n\n            if improved:\n                continue\n\n            # Try to move single items from one bin to another to free empty bins\n            moved = self._try_single_item_moves(bins, bin_loads)\n            if moved:\n                improved = True\n                continue\n\n            # Try pairwise swaps if they improve packing \"tightness\"\n            swapped = self._try_pairwise_swaps(bins, bin_loads)\n            if swapped:\n                improved = True\n                continue\n\n        return bins\n\n    def _best_fit_decreasing(self):\n        items = sorted([(i, w) for i, w in enumerate(self.weights)], key=lambda x: x[1], reverse=True)\n        bins = []\n        bin_loads = []\n        for idx, w in items:\n            best_bin = -1\n            best_rem_after = None\n            for i in range(len(bins)):\n                rem = self.capacity - (bin_loads[i] + w)\n                if rem >= -1e-12:  # allow small numerical tolerance\n                    if best_bin == -1 or rem < best_rem_after:\n                        best_bin = i\n                        best_rem_after = rem\n            if best_bin >= 0:\n                bins[best_bin].append(idx)\n                bin_loads[best_bin] += w\n            else:\n                bins.append([idx])\n                bin_loads.append(w)\n        return bins, bin_loads\n\n    def _try_eliminate_bin(self, bidx, bins, bin_loads):\n        \"\"\"\n        Try to eliminate bin bidx by placing all its items into other bins (best-fit greedy).\n        If successful, update bins and bin_loads and return True. Otherwise leave unchanged and return False.\n        \"\"\"\n        if bidx < 0 or bidx >= len(bins):\n            return False\n        items_to_move = list(bins[bidx])  # original indices\n        # Try greedy placement into the other bins\n        temp_loads = bin_loads.copy()\n        temp_bins = [list(b) for b in bins]\n        temp_bins[bidx] = []  # will remove later\n        temp_loads[bidx] = 0.0\n\n        # Sort items by decreasing weight to place largest first\n        items_sorted = sorted(items_to_move, key=lambda i: self.weights[i], reverse=True)\n        for item in items_sorted:\n            w = self.weights[item]\n            best_bin = -1\n            best_rem = None\n            for i in range(len(temp_bins)):\n                if i == bidx:\n                    continue\n                rem = self.capacity - (temp_loads[i] + w)\n                if rem >= -1e-12:\n                    if best_bin == -1 or rem < best_rem:\n                        best_bin = i\n                        best_rem = rem\n            if best_bin == -1:\n                # cannot place this item -> fail\n                return False\n            temp_bins[best_bin].append(item)\n            temp_loads[best_bin] += w\n\n        # All items placed: remove the empty bin index\n        # Remove bidx\n        del temp_bins[bidx]\n        del temp_loads[bidx]\n\n        # Commit changes\n        bins.clear()\n        bins.extend(temp_bins)\n        bin_loads.clear()\n        bin_loads.extend(temp_loads)\n        return True\n\n    def _try_single_item_moves(self, bins, bin_loads):\n        \"\"\"\n        Try to move single items from one bin to another greedily to free bins.\n        Return True if any move that reduces bin count or empties a bin is done.\n        \"\"\"\n        n_bins = len(bins)\n        # iterate over bins that are least loaded first (more likely to be emptied)\n        order = sorted(range(n_bins), key=lambda i: bin_loads[i])\n        for src in order:\n            if src >= len(bins):\n                continue\n            if len(bins[src]) == 0:\n                continue\n            # try to move items from this bin to other bins\n            items_sorted = sorted(bins[src], key=lambda i: self.weights[i], reverse=True)\n            moved_any = False\n            for item in items_sorted:\n                w = self.weights[item]\n                best_bin = -1\n                best_rem = None\n                for j in range(len(bins)):\n                    if j == src:\n                        continue\n                    rem = self.capacity - (bin_loads[j] + w)\n                    if rem >= -1e-12:\n                        if best_bin == -1 or rem < best_rem:\n                            best_bin = j\n                            best_rem = rem\n                if best_bin != -1:\n                    # perform move\n                    bins[best_bin].append(item)\n                    bin_loads[best_bin] += w\n                    bins[src].remove(item)\n                    bin_loads[src] -= w\n                    moved_any = True\n                    # If source is emptied, remove the bin and return True (reduced bin count)\n                    if len(bins[src]) == 0:\n                        del bins[src]\n                        del bin_loads[src]\n                        return True\n            # if we moved some items but didn't empty the bin, check if any further elimination possible\n            if moved_any:\n                # try to eliminate this bin completely now\n                if self._try_eliminate_bin(src, bins, bin_loads):\n                    return True\n                # otherwise continue to next bin\n        return False\n\n    def _packing_objective(self, bin_loads):\n        \"\"\"\n        A heuristic objective: sum of squared remaining capacities (want smaller).\n        \"\"\"\n        rem = np.array([self.capacity - l for l in bin_loads], dtype=float)\n        rem[rem < 0] = np.inf\n        return float(np.sum(rem * rem))\n\n    def _try_pairwise_swaps(self, bins, bin_loads):\n        \"\"\"\n        Try pairwise swaps between items in different bins that improve the packing objective.\n        If a swap leads to a reduced objective (less wasted space), perform it and return True.\n        \"\"\"\n        n_bins = len(bins)\n        if n_bins < 2:\n            return False\n        base_obj = self._packing_objective(bin_loads)\n        # iterate over pairs of bins\n        for i in range(n_bins):\n            for j in range(i + 1, n_bins):\n                # consider all item pairs\n                for a in list(bins[i]):\n                    wa = self.weights[a]\n                    for b in list(bins[j]):\n                        wb = self.weights[b]\n                        # check if swapping is feasible\n                        new_load_i = bin_loads[i] - wa + wb\n                        new_load_j = bin_loads[j] - wb + wa\n                        if new_load_i <= self.capacity + 1e-12 and new_load_j <= self.capacity + 1e-12:\n                            # compute new objective\n                            temp_loads = bin_loads.copy()\n                            temp_loads[i] = new_load_i\n                            temp_loads[j] = new_load_j\n                            new_obj = self._packing_objective(temp_loads)\n                            if new_obj + 1e-12 < base_obj:\n                                # perform swap\n                                bins[i].remove(a)\n                                bins[i].append(b)\n                                bins[j].remove(b)\n                                bins[j].append(a)\n                                bin_loads[i] = new_load_i\n                                bin_loads[j] = new_load_j\n                                return True\n        return False"
