program = "import random\nimport time\n\nclass BPPSolver:\n    \"\"\"\n    Solves the Bin Packing Problem using a hybrid approach inspired by the\n    Adaptive Hierarchical Negotiation and Memetic Search (AHNMS) metaheuristic.\n\n    This implementation adapts the core concepts of AHNMS to the BPP domain:\n    - **Initialization**: Creates a diverse initial population of solutions using\n      different heuristics (First Fit Decreasing, Best Fit Decreasing, etc.).\n    - **Hierarchical View**: The \"hierarchy\" is implicitly represented by the\n      population of solutions, each offering a different global arrangement.\n    - **Local Search (Transformation Primitives)**: Iteratively improves individual\n      solutions using local search operators like swapping items between bins or\n      moving single items. This corresponds to applying \"transformation primitives\".\n    - **Recombination (Memetic Merging)**: Combines two high-quality parent solutions\n      to create a new offspring, inheriting the best-packed bins from each. This\n      mimics the \"memetic-style structural merging\".\n    - **Negotiation/Repair**: The recombination and local search steps implicitly\n      \"negotiate\" item placements. A repair mechanism ensures all items are packed,\n      handling \"conflicts\" that arise during crossover.\n    - **Adaptive Control/Selection**: The main loop uses a fitness-based selection\n      (tournament) to guide the search towards better solutions, implicitly adapting\n      to the most promising regions of the search space.\n    \"\"\"\n\n    def __init__(self, capacity: int, weights: list[int | float]):\n        \"\"\"\n        Initialize the BPP solver.\n\n        Args:\n            capacity (int): The capacity of each bin.\n            weights (list[int | float]): A list of item weights.\n        \"\"\"\n        self.capacity = capacity\n        # Store items as (index, weight) tuples for easy handling\n        self.items = sorted([(i, w) for i, w in enumerate(weights)], key=lambda x: x[1], reverse=True)\n        self.num_items = len(self.items)\n\n        # --- Algorithm Parameters ---\n        self.population_size = 30\n        self.max_generations = 150\n        self.tournament_size = 3\n        self.crossover_rate = 0.9\n        self.mutation_rate = 0.2  # Probability of applying local search to an individual\n        self.local_search_intensity = 50 # Number of iterations for local search\n        self.stagnation_limit = 30 # Generations without improvement to stop\n\n    def _first_fit(self) -> list[list[int]]:\n        \"\"\"Greedy First Fit Decreasing heuristic to generate a solution.\"\"\"\n        bins = []\n        bin_loads = []\n        for item_index, item_weight in self.items:\n            placed = False\n            for i in range(len(bins)):\n                if bin_loads[i] + item_weight <= self.capacity:\n                    bins[i].append(item_index)\n                    bin_loads[i] += item_weight\n                    placed = True\n                    break\n            if not placed:\n                bins.append([item_index])\n                bin_loads.append(item_weight)\n        return bins\n\n    def _best_fit(self) -> list[list[int]]:\n        \"\"\"Greedy Best Fit Decreasing heuristic.\"\"\"\n        bins = []\n        bin_loads = []\n        for item_index, item_weight in self.items:\n            best_bin_idx = -1\n            min_remaining_space = float('inf')\n            for i in range(len(bins)):\n                if bin_loads[i] + item_weight <= self.capacity:\n                    remaining_space = self.capacity - (bin_loads[i] + item_weight)\n                    if remaining_space < min_remaining_space:\n                        min_remaining_space = remaining_space\n                        best_bin_idx = i\n            if best_bin_idx != -1:\n                bins[best_bin_idx].append(item_index)\n                bin_loads[best_bin_idx] += item_weight\n            else:\n                bins.append([item_index])\n                bin_loads.append(item_weight)\n        return bins\n\n    def _shuffled_first_fit(self) -> list[list[int]]:\n        \"\"\"Generates a solution by applying FFD to a shuffled item list.\"\"\"\n        shuffled_items = self.items[:]\n        random.shuffle(shuffled_items)\n        bins = []\n        bin_loads = []\n        for item_index, item_weight in shuffled_items:\n            placed = False\n            for i in range(len(bins)):\n                if bin_loads[i] + item_weight <= self.capacity:\n                    bins[i].append(item_index)\n                    bin_loads[i] += item_weight\n                    placed = True\n                    break\n            if not placed:\n                bins.append([item_index])\n                bin_loads.append(item_weight)\n        return bins\n\n    def _calculate_fitness(self, solution: list[list[int]]) -> int:\n        \"\"\"Fitness is simply the number of bins used (lower is better).\"\"\"\n        return len(solution)\n\n    def _local_search(self, solution: list[list[int]]) -> list[list[int]]:\n        \"\"\"\n        Improves a solution using local search operators (transformation primitives).\n        \"\"\"\n        current_solution = [b[:] for b in solution]\n        weights_map = {i: w for i, w in self.items}\n        \n        for _ in range(self.local_search_intensity):\n            if len(current_solution) <= 1: break\n\n            # Operator 1: Try to move an item from a sparsely populated bin\n            bin_idx1 = random.randrange(len(current_solution))\n            if not current_solution[bin_idx1]: continue\n            \n            item_idx_in_bin = random.randrange(len(current_solution[bin_idx1]))\n            item_id = current_solution[bin_idx1][item_idx_in_bin]\n            item_weight = weights_map[item_id]\n\n            # Try to move it to another existing bin\n            for bin_idx2 in range(len(current_solution)):\n                if bin_idx1 == bin_idx2: continue\n                \n                bin2_load = sum(weights_map[it] for it in current_solution[bin_idx2])\n                if bin2_load + item_weight <= self.capacity:\n                    # Move successful\n                    current_solution[bin_idx2].append(item_id)\n                    current_solution[bin_idx1].pop(item_idx_in_bin)\n                    if not current_solution[bin_idx1]: # If bin becomes empty, remove it\n                        current_solution.pop(bin_idx1)\n                    return current_solution # Return on first improvement\n\n            # Operator 2: Try to swap two items between bins\n            bin_idx2 = random.randrange(len(current_solution))\n            if bin_idx1 == bin_idx2 or not current_solution[bin_idx2]: continue\n\n            item_idx_in_bin2 = random.randrange(len(current_solution[bin_idx2]))\n            item_id2 = current_solution[bin_idx2][item_idx_in_bin2]\n            item_weight2 = weights_map[item_id2]\n\n            bin1_load = sum(weights_map[it] for it in current_solution[bin_idx1])\n            bin2_load = sum(weights_map[it] for it in current_solution[bin_idx2])\n\n            if (bin1_load - item_weight + item_weight2 <= self.capacity and\n                bin2_load - item_weight2 + item_weight <= self.capacity):\n                # Swap successful\n                current_solution[bin_idx1][item_idx_in_bin] = item_id2\n                current_solution[bin_idx2][item_idx_in_bin2] = item_id\n                # No change in bin count, but might enable future improvements\n        \n        return [b for b in current_solution if b] # Clean up any empty bins\n\n\n    def _crossover(self, parent1: list[list[int]], parent2: list[list[int]]) -> list[list[int]]:\n        \"\"\"\n        Memetic recombination: creates a child by taking the best-packed bins from parents.\n        \"\"\"\n        weights_map = dict(self.items)\n        \n        # Sort bins by fullness (density)\n        p1_bins = sorted(parent1, key=lambda b: sum(weights_map[i] for i in b), reverse=True)\n        p2_bins = sorted(parent2, key=lambda b: sum(weights_map[i] for i in b), reverse=True)\n\n        child = []\n        packed_items = set()\n        \n        # Take bins alternating from parents\n        while p1_bins and p2_bins:\n            if len(p1_bins) > 0:\n                bin_from_p1 = p1_bins.pop(0)\n                if not any(item in packed_items for item in bin_from_p1):\n                    child.append(bin_from_p1)\n                    packed_items.update(bin_from_p1)\n            \n            if len(p2_bins) > 0:\n                bin_from_p2 = p2_bins.pop(0)\n                if not any(item in packed_items for item in bin_from_p2):\n                    child.append(bin_from_p2)\n                    packed_items.update(bin_from_p2)\n\n        # Repair: Pack any remaining items using First Fit\n        unpacked_items = [item for item in self.items if item[0] not in packed_items]\n        \n        if unpacked_items:\n            child_bin_loads = [sum(weights_map[i] for i in b) for b in child]\n            for item_index, item_weight in unpacked_items:\n                placed = False\n                for i in range(len(child)):\n                    if child_bin_loads[i] + item_weight <= self.capacity:\n                        child[i].append(item_index)\n                        child_bin_loads[i] += item_weight\n                        placed = True\n                        break\n                if not placed:\n                    child.append([item_index])\n                    child_bin_loads.append(item_weight)\n                    \n        return child\n\n    def _tournament_selection(self, population: list, fitnesses: list) -> list[list[int]]:\n        \"\"\"Selects an individual from the population using tournament selection.\"\"\"\n        selected_indices = random.sample(range(len(population)), self.tournament_size)\n        best_index = min(selected_indices, key=lambda i: fitnesses[i])\n        return population[best_index]\n\n    def solve(self) -> list[list[int]]:\n        \"\"\"\n        Solve the Bin Packing Problem using the memetic algorithm.\n        \"\"\"\n        # --- Initialization Phase ---\n        # Initialize a diverse pool of candidate solutions\n        population = []\n        population.append(self._first_fit())\n        population.append(self._best_fit())\n        for _ in range(self.population_size - 2):\n            population.append(self._shuffled_first_fit())\n\n        best_solution = min(population, key=self._calculate_fitness)\n        best_fitness = self._calculate_fitness(best_solution)\n        generations_since_improvement = 0\n\n        # --- Main Processing Loop ---\n        for _ in range(self.max_generations):\n            fitnesses = [self._calculate_fitness(sol) for sol in population]\n            \n            new_population = [best_solution] # Elitism\n\n            while len(new_population) < self.population_size:\n                # Select parents\n                parent1 = self._tournament_selection(population, fitnesses)\n                parent2 = self._tournament_selection(population, fitnesses)\n                \n                # Recombine to form a child solution\n                if random.random() < self.crossover_rate:\n                    child = self._crossover(parent1, parent2)\n                else:\n                    child = parent1[:]\n\n                # Apply local improvement (mutation)\n                if random.random() < self.mutation_rate:\n                    child = self._local_search(child)\n                \n                new_population.append(child)\n\n            population = new_population\n            \n            # Evaluate new population and update best solution found\n            current_best_in_pop = min(population, key=self._calculate_fitness)\n            current_best_fitness = self._calculate_fitness(current_best_in_pop)\n\n            if current_best_fitness < best_fitness:\n                best_solution = current_best_in_pop\n                best_fitness = current_best_fitness\n                generations_since_improvement = 0\n            else:\n                generations_since_improvement += 1\n\n            # Trigger strategic move (termination) if stagnated\n            if generations_since_improvement >= self.stagnation_limit:\n                break\n        \n        # --- Post-Processing Phase ---\n        # Final polish on the best solution\n        final_solution = self._local_search(best_solution)\n        if self._calculate_fitness(final_solution) < best_fitness:\n            best_solution = final_solution\n\n        # The AHNMS description returns the best feasible global solution.\n        # Our solutions are always feasible.\n        return best_solution"
