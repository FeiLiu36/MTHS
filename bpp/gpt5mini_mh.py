program =    "import numpy as np\n\nclass BPPSolver:\n    def __init__(self, capacity: int, weights: list[int | float]):\n        \"\"\"\n        Initialize the BPP solver.\n\n        Args:\n            capacity (int): The capacity of each bin.\n            weights (list[int | float]): A list of item weights.\n        \"\"\"\n        self.capacity = float(capacity)\n        self.weights = [float(w) for w in weights]\n        self.num_items = len(weights)\n        # sorted items (index, weight) descending by weight\n        self.items_sorted = sorted([(i, self.weights[i]) for i in range(self.num_items)],\n                                   key=lambda x: x[1], reverse=True)\n        # random generator seeded deterministically from instance for reproducibility\n        seed = int(sum(self.weights) * 1000) % (2**32 - 1)\n        self.rng = np.random.default_rng(seed)\n\n    # -------------------------\n    # Packing primitives\n    # -------------------------\n    def _compute_loads(self, bins):\n        loads = [sum(self.weights[i] for i in b) for b in bins]\n        return loads\n\n    def _is_feasible(self, bins):\n        loads = self._compute_loads(bins)\n        return all(load <= self.capacity + 1e-9 for load in loads)\n\n    def _ffd(self, items=None):\n        # First-Fit Decreasing\n        if items is None:\n            items = self.items_sorted\n        bins = []\n        loads = []\n        for idx, w in items:\n            placed = False\n            for j in range(len(bins)):\n                if loads[j] + w <= self.capacity + 1e-12:\n                    bins[j].append(idx)\n                    loads[j] += w\n                    placed = True\n                    break\n            if not placed:\n                bins.append([idx])\n                loads.append(w)\n        return bins\n\n    def _bfd(self, items=None):\n        # Best-Fit Decreasing\n        if items is None:\n            items = self.items_sorted\n        bins = []\n        loads = []\n        for idx, w in items:\n            best_j = -1\n            best_rem = None\n            for j in range(len(bins)):\n                rem = self.capacity - (loads[j] + w)\n                if rem >= -1e-12:\n                    if best_rem is None or rem < best_rem:\n                        best_rem = rem\n                        best_j = j\n            if best_j >= 0:\n                bins[best_j].append(idx)\n                loads[best_j] += w\n            else:\n                bins.append([idx])\n                loads.append(w)\n        return bins\n\n    def _randomized_greedy(self, items=None, alpha=0.2):\n        # GRASP-like: choose among top-k candidate bins or new bin\n        if items is None:\n            items = self.items_sorted\n        bins = []\n        loads = []\n        for idx, w in items:\n            candidates = []\n            for j in range(len(bins)):\n                rem = self.capacity - loads[j]\n                if rem + 1e-12 >= w:\n                    candidates.append((j, rem))\n            # add option to open new bin with a large rem\n            candidates.append((len(bins), self.capacity))\n            # sort by rem ascending (best fit)\n            candidates.sort(key=lambda x: x[1])\n            k = max(1, int(len(candidates) * alpha))\n            choice = self.rng.integers(0, k)\n            j, _ = candidates[choice]\n            if j == len(bins):\n                bins.append([idx])\n                loads.append(w)\n            else:\n                bins[j].append(idx)\n                loads[j] += w\n        return bins\n\n    # -------------------------\n    # Repair & local improvement\n    # -------------------------\n    def _repair_overfull(self, bins):\n        # Remove items from overfull bins (smallest-first) and repack them\n        loads = self._compute_loads(bins)\n        removed = []\n        for j in range(len(bins)):\n            while loads[j] > self.capacity + 1e-12:\n                # remove smallest item from bin j\n                bin_items = bins[j]\n                smallest_idx = min(bin_items, key=lambda x: self.weights[x])\n                bin_items.remove(smallest_idx)\n                loads[j] -= self.weights[smallest_idx]\n                removed.append((smallest_idx, self.weights[smallest_idx]))\n        if removed:\n            # repack removed items using FFD into existing bins first, then new bins\n            removed.sort(key=lambda x: x[1], reverse=True)\n            for idx, w in removed:\n                placed = False\n                # try best-fit among current bins\n                best_j = -1\n                best_rem = None\n                for j in range(len(bins)):\n                    rem = self.capacity - loads[j]\n                    if rem + 1e-12 >= w:\n                        if best_rem is None or rem < best_rem:\n                            best_rem = rem\n                            best_j = j\n                if best_j >= 0:\n                    bins[best_j].append(idx)\n                    loads[best_j] += w\n                    placed = True\n                if not placed:\n                    bins.append([idx])\n                    loads.append(w)\n        # finally remove any empty bins\n        cleaned = [b for b in bins if len(b) > 0]\n        return cleaned\n\n    def _try_move_improve(self, bins):\n        # local operator: try moving single heavy items to reduce number of bins or max load\n        improved = False\n        loads = self._compute_loads(bins)\n        # try to eliminate small bins by moving their items\n        # sort bins by load ascending to focus on light bins\n        order = sorted(range(len(bins)), key=lambda j: loads[j])\n        for j in order:\n            if j >= len(bins):\n                continue\n            if loads[j] == 0:\n                continue\n            items_j = list(bins[j])  # copy\n            moved_any = False\n            for item in sorted(items_j, key=lambda x: self.weights[x], reverse=True):\n                w = self.weights[item]\n                # try to find a bin to move this item into (excluding j)\n                target = -1\n                best_rem = None\n                for k in range(len(bins)):\n                    if k == j:\n                        continue\n                    rem = self.capacity - (loads[k] + w)\n                    if rem + 1e-12 >= 0:\n                        if best_rem is None or rem < best_rem:\n                            best_rem = rem\n                            target = k\n                if target >= 0:\n                    bins[j].remove(item)\n                    bins[target].append(item)\n                    loads[target] += w\n                    loads[j] -= w\n                    moved_any = True\n                    improved = True\n                    # if bin j empty, remove it and break\n                    if loads[j] <= 1e-12:\n                        break\n            if moved_any and loads[j] <= 1e-12:\n                # remove empty bin\n                bins = [b for b in bins if len(b) > 0]\n                break\n        return bins, improved\n\n    def _try_swap_improve(self, bins):\n        # try pairwise swaps between bins to reduce max load or free a bin\n        loads = self._compute_loads(bins)\n        n = len(bins)\n        improved = False\n        for a in range(n):\n            for b in range(a+1, n):\n                # try swapping one item from a with one from b\n                for ia in list(bins[a]):\n                    for ib in list(bins[b]):\n                        wa = self.weights[ia]; wb = self.weights[ib]\n                        new_load_a = loads[a] - wa + wb\n                        new_load_b = loads[b] - wb + wa\n                        if new_load_a <= self.capacity + 1e-12 and new_load_b <= self.capacity + 1e-12:\n                            # evaluate if swap leads to a better max load distribution or frees a bin\n                            old_max = max(loads[a], loads[b])\n                            new_max = max(new_load_a, new_load_b)\n                            if new_max <= old_max + 1e-12:\n                                # perform swap\n                                bins[a].remove(ia); bins[b].remove(ib)\n                                bins[a].append(ib); bins[b].append(ia)\n                                loads[a] = new_load_a; loads[b] = new_load_b\n                                improved = True\n                                # if a or b became empty remove empties later\n                                if len(bins[a]) == 0 or len(bins[b]) == 0:\n                                    bins = [bb for bb in bins if len(bb) > 0]\n                                    return bins, True\n                                break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n        return bins, improved\n\n    # -------------------------\n    # Memetic recombination\n    # -------------------------\n    def _crossover(self, p1, p2):\n        # Select a subset of bins from p1 to keep, then fill remaining items from p2 using best-fit\n        bins1 = [list(b) for b in p1]\n        bins2 = [list(b) for b in p2]\n        loads1 = self._compute_loads(bins1)\n        m = len(bins1)\n        if m == 0:\n            return self._ffd()\n        # select proportion of bins to keep (favor larger bins)\n        sizes = [len(b) for b in bins1]\n        # probability to keep each bin proportional to its load\n        load_sum = sum(loads1)\n        if load_sum <= 0:\n            keep_mask = [False] * m\n        else:\n            probs = [l / load_sum for l in loads1]\n            keep_mask = [self.rng.random() < (0.5 + 0.5 * p) for p in probs]\n        # ensure at least one bin kept\n        if not any(keep_mask):\n            keep_mask[self.rng.integers(0, m)] = True\n        new_bins = []\n        kept_items = set()\n        for j, keep in enumerate(keep_mask):\n            if keep:\n                new_bins.append(list(bins1[j]))\n                kept_items.update(bins1[j])\n        # collect leftover items from both parents not kept\n        leftovers = []\n        for b in bins1 + bins2:\n            for idx in b:\n                if idx not in kept_items:\n                    leftovers.append((idx, self.weights[idx]))\n                    kept_items.add(idx)  # avoid duplicates\n        # pack leftovers using best-fit into existing new_bins then add new bins\n        loads_new = self._compute_loads(new_bins)\n        for idx, w in sorted(leftovers, key=lambda x: x[1], reverse=True):\n            placed = False\n            best_j = -1\n            best_rem = None\n            for j in range(len(new_bins)):\n                rem = self.capacity - loads_new[j]\n                if rem + 1e-12 >= w:\n                    if best_rem is None or rem < best_rem:\n                        best_rem = rem\n                        best_j = j\n            if best_j >= 0:\n                new_bins[best_j].append(idx)\n                loads_new[best_j] += w\n                placed = True\n            else:\n                new_bins.append([idx])\n                loads_new.append(w)\n        # final repair if overfull\n        new_bins = self._repair_overfull(new_bins)\n        return new_bins\n\n    # -------------------------\n    # Pool management & operators\n    # -------------------------\n    def solve(self) -> list[list[int]]:\n        # Parameters\n        max_iters = 300 + 5 * self.num_items\n        pool_size = max(6, min(30, 6 + self.num_items // 5))\n        stagnation_limit = 80\n        # lower bound\n        total_weight = sum(self.weights)\n        lb = int(np.ceil(total_weight / self.capacity - 1e-12))\n        # initial pool seed with variants\n        pool = []\n\n        def add_to_pool(bins):\n            # ensure feasible\n            if not self._is_feasible(bins):\n                bins = self._repair_overfull(bins)\n            # sort bins by decreasing load to give canonical form\n            bins = sorted([sorted(b) for b in bins], key=lambda b: -sum(self.weights[i] for i in b))\n            # deduplicate by signature\n            sig = tuple(tuple(b) for b in bins)\n            for s in pool:\n                if s['sig'] == sig:\n                    return False\n            loads = self._compute_loads(bins)\n            entry = {'bins': bins, 'loads': loads, 'num_bins': len(bins), 'sig': sig, 'age': 0}\n            pool.append(entry)\n            return True\n\n        # seed: FFD, BFD, randomized, single-item bins then merge\n        add_to_pool(self._ffd())\n        add_to_pool(self._bfd())\n        add_to_pool(self._randomized_greedy(alpha=0.15))\n        # also try greedy grouping coarse partitions\n        # coarse partitions: group items into blocks and pack block-wise then unpack\n        for block in [2, 3, 5]:\n            items = list(self.items_sorted)\n            grouped = []\n            for i in range(0, len(items), block):\n                subset = items[i:i+block]\n                # pack subset optimistically into one bin if fits\n                if sum(w for _, w in subset) <= self.capacity + 1e-12:\n                    grouped.append([idx for idx, _ in subset])\n                else:\n                    # fallback: put each alone\n                    for idx, _ in subset:\n                        grouped.append([idx])\n            # now repair grouped into bins using BFD on single items\n            flat = []\n            for g in grouped:\n                for idx in g:\n                    flat.append((idx, self.weights[idx]))\n            add_to_pool(self._bfd(flat))\n        # fill pool with randomised solutions\n        while len(pool) < pool_size:\n            alpha = float(self.rng.uniform(0.05, 0.4))\n            add_to_pool(self._randomized_greedy(alpha=alpha))\n\n        # adaptive operator weights\n        operators = ['move', 'swap', 'crossover', 'random_repack']\n        weights = {op: 1.0 for op in operators}\n        credits = {op: 0.0 for op in operators}\n        best = min(pool, key=lambda s: s['num_bins'])\n        best_solution = best['bins']\n        best_k = best['num_bins']\n        it = 0\n        stagn = 0\n\n        while it < max_iters and best_k > lb and stagn < stagnation_limit:\n            it += 1\n            # age entries\n            for s in pool:\n                s['age'] += 1\n            # select parents\n            # tournament selection biased to better solutions\n            def select_parent():\n                k = min(4, len(pool))\n                ids = self.rng.choice(len(pool), size=k, replace=False)\n                chosen = min((pool[i] for i in ids), key=lambda x: x['num_bins'])\n                return chosen\n            parent1 = select_parent()\n            parent2 = select_parent()\n            # select operator by roulette on weights\n            w_total = sum(weights.values())\n            r = self.rng.random() * w_total\n            acc = 0.0\n            chosen_op = None\n            for op, w in weights.items():\n                acc += w\n                if r <= acc:\n                    chosen_op = op\n                    break\n            # apply operator\n            child_bins = None\n            if chosen_op == 'move':\n                # local move from parent1\n                bins = [list(b) for b in parent1['bins']]\n                bins, improved = self._try_move_improve(bins)\n                if not improved:\n                    # try small perturbation: remove a random item and repack\n                    idx = self.rng.integers(0, self.num_items)\n                    # remove item if present\n                    found = False\n                    for b in bins:\n                        if idx in b:\n                            b.remove(idx)\n                            found = True\n                            break\n                    if found:\n                        # repack removed item via best-fit\n                        loads = self._compute_loads(bins)\n                        placed = False\n                        for j in range(len(bins)):\n                            if loads[j] + self.weights[idx] <= self.capacity + 1e-12:\n                                bins[j].append(idx)\n                                placed = True\n                                break\n                        if not placed:\n                            bins.append([idx])\n                child_bins = bins\n            elif chosen_op == 'swap':\n                bins = [list(b) for b in parent1['bins']]\n                bins, improved = self._try_swap_improve(bins)\n                if not improved:\n                    # try cross-swap with parent2\n                    # take some bins from parent1 and parent2 and attempt to swap items\n                    bins_a = [list(b) for b in parent1['bins']]\n                    bins_b = [list(b) for b in parent2['bins']]\n                    # simple merge then swap\n                    merged = self._crossover(bins_a, bins_b)\n                    child_bins = merged\n                else:\n                    child_bins = bins\n            elif chosen_op == 'crossover':\n                bins = self._crossover(parent1['bins'], parent2['bins'])\n                child_bins = bins\n            elif chosen_op == 'random_repack':\n                # take parent1, remove a small percent of items and repack them randomly\n                bins = [list(b) for b in parent1['bins']]\n                all_items = [i for b in bins for i in b]\n                k_remove = max(1, int(len(all_items) * self.rng.uniform(0.05, 0.2)))\n                removed = set(self.rng.choice(all_items, size=k_remove, replace=False))\n                remaining = []\n                for b in bins:\n                    for i in b:\n                        if i not in removed:\n                            remaining.append((i, self.weights[i]))\n                # repack remaining with BFD then add removed with randomized greedy\n                base = self._bfd(sorted(remaining, key=lambda x: x[1], reverse=True))\n                add = [(i, self.weights[i]) for i in removed]\n                add_sorted = sorted(add, key=lambda x: x[1], reverse=True)\n                # place removed items into base\n                loads = self._compute_loads(base)\n                for idx, w in add_sorted:\n                    placed = False\n                    best_j = -1; best_rem = None\n                    for j in range(len(base)):\n                        rem = self.capacity - loads[j]\n                        if rem + 1e-12 >= w:\n                            if best_rem is None or rem < best_rem:\n                                best_rem = rem; best_j = j\n                    if best_j >= 0:\n                        base[best_j].append(idx)\n                        loads[best_j] += w\n                    else:\n                        base.append([idx])\n                        loads.append(w)\n                child_bins = base\n            else:\n                child_bins = self._ffd()\n\n            if child_bins is None:\n                child_bins = self._ffd()\n\n            # repair if necessary\n            if not self._is_feasible(child_bins):\n                child_bins = self._repair_overfull(child_bins)\n\n            # apply quick local improvements\n            for _ in range(2):\n                child_bins, _ = self._try_move_improve(child_bins)\n                child_bins, _ = self._try_swap_improve(child_bins)\n\n            # add to pool if interesting\n            added = add_to_pool(child_bins)\n            # evaluate outcome and assign credit\n            new_num = min(pool, key=lambda s: s['num_bins'])['num_bins'] if pool else len(child_bins)\n            # determine if we improved global best\n            candidate = min(pool, key=lambda s: s['num_bins'])\n            if candidate['num_bins'] < best_k:\n                # improvement\n                best_k = candidate['num_bins']\n                best_solution = candidate['bins']\n                credits[chosen_op] += 2.0\n                stagn = 0\n            else:\n                # small credit if candidate equals parent's quality\n                credits[chosen_op] += 0.1 if added else 0.0\n                stagn += 1\n\n            # periodically update operator weights from credits (softmax-ish)\n            if it % 10 == 0:\n                # exponential smoothing\n                for op in operators:\n                    weights[op] = 0.7 * weights[op] + 0.3 * (1.0 + credits[op])\n                # normalize and keep small floor\n                min_w = 1e-3\n                total = sum(max(min_w, w) for w in weights.values())\n                for op in operators:\n                    weights[op] = max(min_w, weights[op]) * len(operators) / total\n                # decay credits\n                for op in operators:\n                    credits[op] *= 0.4\n\n            # prune pool to keep diversity: prefer younger & better\n            pool.sort(key=lambda s: (s['num_bins'], s['age']))\n            if len(pool) > pool_size:\n                pool = pool[:pool_size]\n\n            # early stop if optimal LB reached\n            if best_k <= lb:\n                break\n\n        # final polishing: apply final local search to best_solution\n        final_bins = [list(b) for b in best_solution]\n        improved = True\n        loop = 0\n        while improved and loop < 50:\n            loop += 1\n            final_bins, m1 = self._try_move_improve(final_bins)\n            final_bins, m2 = self._try_swap_improve(final_bins)\n            improved = m1 or m2\n        # ensure feasible and canonicalize\n        if not self._is_feasible(final_bins):\n            final_bins = self._repair_overfull(final_bins)\n        final_bins = sorted([sorted(b) for b in final_bins], key=lambda b: -sum(self.weights[i] for i in b))\n        return final_bins"
